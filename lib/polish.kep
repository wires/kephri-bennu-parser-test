package(
    prog,
    evaluate)
with
    import 'bennu::parse' {
            always,
            bind,
            binds,
            choice,
            attempt,
            either,
            eof,
            enumeration,
            expected,
            many,
            many1,
            next,
            rec,
            run
    },
    import 'bennu::text' {
            character, digit, letter, space
    },
    import 'bennu::lang' {
            between, then
    },
    import 'nu-stream::stream' {foldl}
in {

var join = foldl @ ((+), '');

var beginSpace = many(space);

var token = \p -> then(p, many(space));

var plus = character <| '+';
var times = character <| '*';

var op = \x -> always({'operator': x});

var add = next(plus, op('coproduct'));
var mul = next(times, op('product'));
    
var operator = choice(add, mul);

var number = bind(
    many1(digit),
    join \> parseInt \> always
);

var label = bind(
    many1(letter),
    join \> (\x -> x) \> always
);

var expr = rec(\expr ->
    either(
        binds(
            enumeration(
                token <| operator |> (expected @ 'operator'),
                expr |> (expected @ 'expression'),
                expr |> (expected @ 'expression')),
            \op, a, b -> always({'operator': op, 'x': a, 'y': b})),
        
        token <| number |> (expected @ 'number')));


var tag = token <| label;

var colon = token <| character <| ':';
var equals = token <| character <| '=';

var header = enumeration(tag, colon, tag);

var body = enumeration(tag, equals, expr);


var s = many1(choice(
    attempt(header),
    attempt(body)
));

prog = between(beginSpace, eof, header);

evaluate = run @ prog;

}